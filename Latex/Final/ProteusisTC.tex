\chapter{Proteus is Turing Complete}\label{chapter:ProteusTC}

This section will describe how we will construct the proof showing that Proteus is TC.

\section{Useful information to be used in the proof}

First, I will discuss features about Proteus programs on a theoretical level.
Then, I will discuss features about the Proteus language that allow for the creation of a TM.
This is the background information that will guide the construction of the proof outline and ultimately the proof itself.

\subsection{Undecidable input}\label{subsec:UndecidableInput}

Because Proteus is a higher-level programming language, we can leverage the usage of Rice's Theorem, Theorem \ref{thm:RiceThm}.
Thus, given any input it is impossible to determine an answer to the Halting Problem.
Furthermore, one cannot determine if there is an actor that will be told to switch to a particular state.
With this knowledge, it is understood that any given Proteus program is undecidable.
Thus, I will look at how to create a TM in Proteus.

\subsection{Requirements of a TM}\label{subsec:ReqsofTM}

In this section, I will point out critical pieces of Proteus that prove useful to create a TM.
We can see that the core features to create a TM, seen previously in sections \ref{subsec:TMLogicalDesign} and \ref{subsubsec:ProgCalc}, include:
\begin{enumerate}
    \item Arithmetic and Logical Processing
    \item Memory storage and manipulation
    \item Conditional Logic
    \item Looping Logic
    \item Input/Output
\end{enumerate}

Recall the proteus grammar seen in section \ref{subsec:ProteusGrammar}.
I will now describe from the Proteus grammar how to construct/use Proteus creating each part of the TM.

\subsubsection{Arithmetic and Logical Processing}\label{subsubsec:ArithLogProc}

The grammar provides the following definitions for arithmetic and logical processing:
\begin{itemize}
    \item BinOp
    \item Type
    \item ConstExpr
\end{itemize}

'BinOp' handles all binary operations for both arithmetic and logical calculation.
Some features include addition, subtraction, multiplication, division, modular arithmetic, equivalence relations, and, and or.
Looking at brainfuck in section \ref{subsubsec:EsotericPL}, one can notice that the only necessary mathematical operations are addition and subtraction.
Furthermore, the only logical processing is seen in the looping mechanism.
If the value at the pointer is 0 and the input token is a '[', then the loop is skipped.
This means that there is an equality check which returns a boolean result.

Looking deeper at the types of Proteus, type consists of all the possible types that are built into the language:
\begin{itemize}
    \item int
    \item string
    \item boolean
    \item actorname
    \item statename
    \item eventname
\end{itemize}

Despite allowing for division, the set of integers is closed under truncation, which is how Proteus handles cases where normally it wouldn't be.
eg. 5 / 2 = 2.5, but under truncation 5 / 2 = 2.
These truncation rules are similar to those seen in other languages such as Java and C, \href{https://www.javatpoint.com/what-is-truncation-in-java}{in JAVA} \href{https://www.geeksforgeeks.org/trunc-truncf-truncl-c-language/}{in C}.

'ConstExpr' describes the 3 simple data types: Int, String, and Boolean.
These 3 types are capable of mimicking the behavior of brainfuck as well.

\subsubsection{Memory Storage and Manipulation}\label{subsubsec:MemStoManip}

The grammar provides the following definitions for memory storage and manipulation:
\begin{itemize}
    \item DefHSM
    \item DefState
    \item DefGlobalConst
    \item DecStmt
    \item AssignStmt
    \item SendStmt
\end{itemize}

'HSM' are Hierarchical State Machines which are actors in the language.
These state machines utilize states to determine logical processing.
These logical processes may utilize local or global variables that are stored, via the 'DecStmt' and 'DefGlobalConst' definitions respectively.

To modify data, the 'AssignStmt' was defined which allows for modifying the value of a given variable.
State Machines can modify state via the 'SendStmt' command.
Utilizing 'SendStmt', state machines can modify the state of themselves and other state machines as well.

\subsubsection{Conditional Logic}\label{subsubsec:CondLog}

The grammar provides the following definitions for conditional logic:
\begin{itemize}
    \item GoStmt
    \item JustGoStmt
    \item GoIfStmt
    \item ElseGoStmt
    \item IfStmt
\end{itemize}

Conditional Logic or Branching is necessary for a TM to compute any calculable function (see: Theorem \ref{thm:CTT}).
'GoStmt' is considered either a 'JustGoStmt' or a 'GoIfStmt', which are used to switch between states of a given HSM.
Similarly, the 'ElseGoStmt' switches to a particular state of a given HSM if the condition from the 'GoIfStmt' fails.

The 'IfStmt' is utilized for conditional logic within the processing of the state machines, and is akin to the standard if statements in other programming languages.
It is defined recursively to allow for nested "If ... else if.... else ..." statements.
These definitions allow for conditional statements to occur for a given HSM and within the code itself.

\subsubsection{Looping Logic}\label{subsubsec:LoopLog}

The only looping logic that can be seen in the garmmar that is built in, is the:
\begin{itemize}
    \item WhileStmt
\end{itemize}

This is the only necessary form of looping, as it can be broken by conditional statements and is capable of performing like other loops such as the do-while, for, and so forth.
This allows for more complex logical processing, such as recursion, which is a necessary requirement for TMs to perform any calculation.
A simplistic example of a problem that requires recursion would be the Ackermann Function.
See the definition of the Ackermann function here:
\[
\begin{aligned}
    A(0, n) &= n + 1\\
    A(m + 1, 0) &= A(m,1)\\
    A(m + 1, n + 1) &= A(m,\hspace{0.1cm} A(m + 1,n))
\end{aligned}
\]

Although being able to compute the Ackermann function requires recursion, it doesn't conclude that any system that can compute it is TC.
It was created to show that not all total computable functions are primitively recursive \cite{AckermannPR}.
The Ackermann function exists to show that not all functions can be represented with for loops, which is what primitive recursive functions are \cite{RecursiveFuncs}.
Nonetheless, all computable functions (regardless of their expression) are capable of being calculated by a TM, as stated by the Church-Turing Thesis (Theorem \ref{thm:CTT}).

\subsubsection{Input/Output}\label{subsubsec:IO}

Looking at the grammar definitions for:
\begin{itemize}
    \item Stmt
    \item PrintlnStmt
    \item PrintStmt
    \item SendStmt
\end{itemize}

From 'Stmt' I would like to highlight the 'SendStmt' command.
'SendStmt' is utilized to send events to a particular State Machine (i.e. an output).
By default, all actors are able to receive events.
'PrintlnStmt' and 'PrintStmt' are the standard print and println commands that are well known from other languages which serve as output to the console.
Although there is no explicit way to allow for input from the systems grammar dynamically, this is unnecessary as it can be preconfigured before runtime.
Thus, there exists a way to send inputs before the program is run via static input of values.

\section{Proof Outline}\label{sec:ProofOutline}

By showing that any input to Proteus programs are undecidable and it is possible to create a TM in Proteus, Proteus can be shown to be TC.
This proof leverages the usage of both the Church-Turing Thesis, Theorem \ref{thm:CTT}, and Rice's Theorem, Theorem \ref{thm:RiceThm}.

I will explicitly create a TM using the built-in features seen previously in section \ref{subsec:ReqsofTM}.
After showing how to create a TM within Proteus, I will use Proteus to implement Rule 110 and a brainfuck interpreter.
This is to demonstrate that the system is TC, verified previously in sections \ref{subsec:InterpreterTC} and \ref{subsubsec:Rule110}.

\begin{enumerate}
    \item Define the set of internal states
    \item Define the input alphabet
    \item Define the tape alphabet
    \item Define the state transitions
    \item Define the blank symbol
    \item Define the initial state
    \item Define the final states
\end{enumerate}

\section{Proof}\label{sec:Proof}

The proof begins

\section{Implementing Rule 110}\label{sec:ImplementRule110}

Implementation of Rule 110 that is a demonstration of TC.

\section{Interpreter for Brainfuck}\label{sec:ImplementBF}

(
EN - I dont think i will do this one, but I leave it as an option.
)