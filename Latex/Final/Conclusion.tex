\chapter{Conclusion}\label{chapter:Concl}

This chapter will summarize, reflect, and look beyond the scope of this thesis project.

\section{Summary}\label{sec:summary}

Previously, several methods of demonstrating that a system can proven TC were discussed in chapter \ref{chapter:ProofApproachesForTC}.
Of these, the automata theory section \ref{subsec:AutomataThy}, and software engineering approaches section \ref{subsec:SoftwareImplementation}, were utilized in this proof for their direct application to Proteus.
Utilizing Rice's Theorem, Theorem \ref{thm:RiceThm}, I demonstrated that with an undecidable input and the construction of a TM in the system that Proteus is TC.
Because Proteus is a programming language, I also implemented some software implementations of TC programs.
The choice of CGoL and Rule110 is because of the application of each state machine representing a cell on a grid; similar to the infinite tape described in the proof.
After showing how to create a TM in Proteus, the proof is technically complete.
I went further to showcase Proteus code in action and doubling as a secondary proof/implementation of Turing Completeness.
This concludes the goal of the thesis.

\section{Personal Reflections and Remarks}\label{sec:RefRem}

Turing Completeness was a topic discussed only in my higher level courses (300+) for my undergraduate degree.
Even when it was discussed, it was seldomly discussed on a very deep level outside of the Automata classes, which admittedly makes sense.
However, it seems that such a theoretical machine of such power and capability would be discussed across the other classes.
It seemed to me that perhaps there was a fundamental reason which spearheaded my interest into the topic.
Turing Machines seemed simplistic to understand based on the Church-Turing Thesis, Theorem \ref{thm:CTT}.
Despite this, there exist many equivalent definitions of a TM from automata theory, such as a DTM and a NDTM.
Then I was interested in some systems that were unintentionally TC such as Excel or Java Generics \cite{ExcelTC,JavaGenericsTC}.
There exist many unassuming systems that are TC by allowing for the creation of a TM or through other various methods \cite{AccTC,AccTC2}.

Working with NASA JPL and through CSUN STEAHM ARCS, I was introduced to the Proteus project where I was able to assist by analyzing the theoretical implications of the system that would eventually be used to power rovers for interstellar research.
My intentions were to show the computation power of this language and highlight some theoretical implications that may have otherwise been unthought of.

\subsection{Importance of Turing Completeness}\label{subsec:ImportanceTC}

For a system to be shown TC, Theorem \ref{thm:CTT}, means that it can compute just about any practical result.
This means that it would be a major security vulnerability if a bad actor was able to utilize the TM for nefarious deeds.
Thus, it's a matter of security as well as theory.
By having a system that is TC, one must be extremely careful about how to handle security access and permissions.
Mismanagement of memory may allow for adversaries to obtain access to memory they shouldn't and furthermore exploit the system.
Such exploits have already been seen in systems that were shown TC \cite{SecVuln}.

\section{Further Research and Improvements}\label{sec:FurtherResImprov}

This section outlines alternative proofs to show Proteus is TC.
It also describes some improvements to the proof provided in chapter \ref{chapter:ProteusTC}.

\subsection{Utilizing the other approaches discussed}

Omitting the brainfuck interpreter was intentional.
This is because to properly implement an interpreter for brainfuck, I would have needed to implement a system to represent a dynamic input from the user.
This can be circumvented by some creative usage of state machines and understanding how to statically implement the input from the user (pre-feeding), which would otherwise be impossible.

Because of the truncation to maintain closure of the integers with arithmetic, there is no direct implementation of a calculator using Proteus.
The other parts of the calculator to demonstrate a TC system are applicable, seen in section \ref{subsubsec:ProgCalc}.
If one was able to represent decimal values by utilizing state machines for holding the whole value portion and the decimal portion, then it would be possible to create a programmable calculator.
The crux of the proof remains how to represent and achieve these numbers.
This is also a possible improvement and method to demonstrate that Proteus is TC.

The mathematical approach for lambda calculus (section \ref{sec:Maths}) is not applicable because Proteus is not a Functional Programming language and would require more in-depth theoretical definitions.

Using the Modified Harvard Architecture to create a TM, seen within section \ref{subsubsec:Arch}, would quickly prove to be very verbose.
This is because it relies on creating logical gates, one at a time, then creating the larger circuitry compontents like the ALU.
Even more, it would still require a way to interact with the I/O system which may be modeled similar to the one previously mentioned for the brainfuck interpreter.
Additionally, the restriction of truncation along the integers proves challenging in representing arithmetic such as division within the ALU.
Nevertheless it is possible due to Proteus being TC, but remains a notion for future work.

\section{Concluding Comments}\label{sec:ConclComm}

By analyzing how other disciplines define Turing Completeness and prove systems TC is remarkable.
These complex proofs are all equivalent in determining that a system is TC, the most powerful theoretical machine that exists.
By performing this survey into theory across the disciplines, the gap between them reduces.

Proving that a novel programming language, Proteus, is TC through the several methods discussed shows that these methods are useful and verifiable.
Perhaps not all are applicable, but all are equivalent in purpose and truth.